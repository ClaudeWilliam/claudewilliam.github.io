<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>浅谈Redis的结构和应用 | Hill's Notes</title><meta name="keywords" content="Redis"><meta name="author" content="Hill"><meta name="copyright" content="Hill"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言Redis我想大家都很熟悉，Redis是Key-Value存储的，它是一个完全内存存储，当然Redis也可以进行持久化（RDB，AOF），持久化是在硬盘上的。Redis最常用是用Redis去做缓存，也可以做消息队列和数据库，内置Lua脚本引擎（分布式锁原子操作），当Redis内存使用完会使用默认LRU算法清除Key，同时还有Sentinel的高可用集群(HA)和Cluster集群实现分片存储和">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈Redis的结构和应用">
<meta property="og:url" content="https://blog.51cloud.win/2020/03/16/%E6%B5%85%E8%B0%88Redis/index.html">
<meta property="og:site_name" content="Hill&#39;s Notes">
<meta property="og:description" content="前言Redis我想大家都很熟悉，Redis是Key-Value存储的，它是一个完全内存存储，当然Redis也可以进行持久化（RDB，AOF），持久化是在硬盘上的。Redis最常用是用Redis去做缓存，也可以做消息队列和数据库，内置Lua脚本引擎（分布式锁原子操作），当Redis内存使用完会使用默认LRU算法清除Key，同时还有Sentinel的高可用集群(HA)和Cluster集群实现分片存储和">
<meta property="og:locale">
<meta property="og:image" content="https://blog.51cloud.win/img/00018.jpg">
<meta property="article:published_time" content="2020-03-16T01:21:08.000Z">
<meta property="article:modified_time" content="2021-04-17T05:53:15.346Z">
<meta property="article:author" content="Hill">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.51cloud.win/img/00018.jpg"><link rel="shortcut icon" href="/img/flag.jpg"><link rel="canonical" href="https://blog.51cloud.win/2020/03/16/%E6%B5%85%E8%B0%88Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Hill","link":"Link: ","source":"Source: Hill's Notes","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-17 13:53:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/dog.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/00018.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hill's Notes</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">浅谈Redis的结构和应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-03-16T01:21:08.000Z" title="Created 2020-03-16 09:21:08">2020-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-04-17T05:53:15.346Z" title="Updated 2021-04-17 13:53:15">2021-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="浅谈Redis的结构和应用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Redis我想大家都很熟悉，Redis是Key-Value存储的，它是一个完全内存存储，当然Redis也可以进行持久化（RDB，AOF），持久化是在硬盘上的。Redis最常用是用Redis去做缓存，也可以做消息队列和数据库，内置Lua脚本引擎（分布式锁原子操作），当Redis内存使用完会使用默认LRU算法清除Key，同时还有Sentinel的高可用集群(HA)和Cluster集群实现分片存储和内存扩大（Hash一致性算法：扩容或者宕机后不会导存储发生变化即大量key由于Hash改变导致失效，Hash存储和之前保持一致）。</p>
<p>Redis常用的数据结构大家也都熟悉，Redis常用数据结构我想大家也都知道，除了最常用的String，List，Set，Hash，Zset；在Redis2.2版本引进BitMap，2.8版本引入HyperLogLog数据结构，3.2版本引入了存放地理信息的GEO数据结构和指令；5.0版本还引入Stream有点像抽象的日志数据结构，像日志文件一样，通常是以append only模式下打开的文件来实现的，不过这里我们久不涉及了。丰富了Redis的数据类型也增加Redis解决问题的其他能力，所以直到现在我所了解的Redis主要有8种数据类型，后面如果增加我们在增加。</p>
<p>Redis一般都是暂时性存储，不会做永久性存储，毕竟内存的还是有限的，同时内存的价格也比较贵，所以在使用Redis都会设置Key的过期时间，无论这个过期Key有多长（一般由业务决定）。这样不会导致Redis被一些无用的Key所撑爆，尽管Redis已经有LRU的淘汰策略。</p>
<p>我们主要讨论时redis4.0版本的数据结构类型。5.0版本先不涉及，现在好多redis版本还是在3.0版本。</p>
<h4 id="Redis常用的5种数据结构"><a href="#Redis常用的5种数据结构" class="headerlink" title="Redis常用的5种数据结构"></a>Redis常用的5种数据结构</h4><p>redis常用的五种类型就是String，List，Set，Hash，Zet。这里面Zet应该也不算是常用。这里最常用的应该就是String。</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>String是Redis最基本的数据结构，它是最常用的Redis数据结构，当你想要缓存一个值或者字符串的时候String最好的选择。关于String操作的指令也很简单，主要就是SET，GET这两种命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET w3ckey redis </span><br><span class="line">OK </span><br><span class="line">redis 127.0.0.1:6379&gt; GET w3ckey </span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>Redis除了这两种常用的指令，还有一些可以其他功能的指令。</p>
<p><code>SETNX key value</code>只有在 key 不存在时设置 key 的值。这个主要用于做分布式锁，在抢占资源的时候，一个Key设置好了就不允许其他相同的Key在设置进来，实现了互斥。不过老版本的一般用<code>SETNX</code>和<code>EXPIRE</code>这两个指令来实现这样就会有两个指令不同步问题，因为两条指令不是原子操作有有的时候就会与异常情况要处理。现在Redis的Redisson里面有自带分布式锁，它可以通过Lua脚本实现分布式锁。就是jedis也提供了SET一个函数，可以指定NX和过期时间的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Redis通过Lua脚本设置锁</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId,</span></span></span><br><span class="line"><span class="function"><span class="params">                RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    <span class="comment">// 4.使用 EVAL 命令执行 Lua 脚本获取锁</span></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime,</span><br><span class="line">                        getLockName(threadId));</span><br></pre></td></tr></table></figure>

<p>1、如果通过 <code>exists</code> 命令发现当前 key 不存在，即锁没被占用，则执行 <code>hset</code> 写入 Hash 类型数据 <strong>key:全局锁名称</strong>（例如共享资源ID）, <strong>field:锁实例名称</strong>（Redisson客户端ID:线程ID）, <strong>value:1</strong>，并执行 <code>pexpire</code> 对该 key 设置失效时间，返回空值 <code>nil</code>，至此获取锁成功。</p>
<p>2、如果通过 <code>hexists</code> 命令发现 Redis 中已经存在当前 key 和 field 的 Hash 数据，说明当前线程之前已经获取到锁，因为这里的锁是<strong>可重入</strong>的，则执行 <code>hincrby</code> 对当前 key field 的值<strong>加一</strong>，并重新设置失效时间，返回空值，至此重入获取锁成功。</p>
<p>3、最后是锁已被占用的情况，即当前 key 已经存在，但是 Hash 中的 Field 与当前值不同，则执行 <code>pttl</code> 获取锁的剩余存活时间并返回，至此获取锁失败。</p>
<p>Jedis 中是这种SET key value [EX seconds] [PX milliseconds] [NX|XX]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * SET key value [EX seconds] [PX milliseconds] [NX|XX]</span></span><br><span class="line"><span class="comment">    * 将字符串值 value 关联到 key 。</span></span><br><span class="line"><span class="comment">    * 如果 key 已经持有其他值， SET 就覆写旧值，无视类型。</span></span><br><span class="line"><span class="comment">    * 对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</span></span><br><span class="line"><span class="comment">    * 可选参数</span></span><br><span class="line"><span class="comment">    * 从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</span></span><br><span class="line"><span class="comment">    * EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</span></span><br><span class="line"><span class="comment">    * PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</span></span><br><span class="line"><span class="comment">    * NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</span></span><br><span class="line"><span class="comment">    * XX ：只在键已经存在时，才对键进行设置操作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SET</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设置不存在key为name时设置并在15秒后过期,一般这就是redis锁操作实现。</span></span><br><span class="line">       jedis.set(KEY, VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">15</span>);</span><br><span class="line">       out(jedis.get(KEY));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我一般常用的是jedis的SET方法，这样比较简单。不过上面两种都需要Redis2.6版本以上，不过现在Redis已经5.0版本都有了。如果还是2.6版本那就赶紧升级一下，还可以体验一下其他的新功能。</p>
<p><code>INCR key </code>将 key 中储存的数字值增一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET page_view 20</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCR page_view</span><br><span class="line">(integer) 21</span><br><span class="line">redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存(底层数据结构是sds)</span><br><span class="line">&quot;21&quot;</span><br></pre></td></tr></table></figure>

<p>  <code> INCRBY key increment</code>将 key 所储存的值加上给定的增量值（increment） 。指定增加的步长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">edis&gt; SET rank 50</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCRBY rank 20</span><br><span class="line">(integer) 70</span><br><span class="line">redis&gt; GET rank</span><br><span class="line">&quot;70&quot;</span><br><span class="line"> </span><br><span class="line"># key 不存在时</span><br><span class="line">redis&gt; EXISTS counter</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; INCRBY counter 30</span><br><span class="line">(integer) 30</span><br><span class="line">redis&gt; GET counter</span><br><span class="line">&quot;30&quot;</span><br><span class="line"></span><br><span class="line"># key 不是数字值时</span><br><span class="line">redis&gt; SET book &quot;long long ago...&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCRBY book 200</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>

<p>这两个指令在生成唯一编号的时候会很好用，也就是一个发号器，可以生成订单编号（这样保证的唯一性和顺序性对于存储时有很大好处），当然可以用数据库和雪花算法等等。这种增长值限制在 64 位(bit)有符号数字表示之内。</p>
<p>同样也有<code>DECR Key</code> 和<code>DECRBY key decrement</code>这种也可以用在分布式的并发控制器。做一个分布式的<code>CountDownLatch</code> 做资源的控制，当Key 减小到0时候才会一起执行。</p>
<p>使用<code>INCRBY</code>可以做原子计数器，对于某个用户请求做记录，这样简单知道这个用户请求多少次网站。同样根据这个也可以去做限流控制，对于某个用户的频繁操作做熔断。</p>
<p>同样String还有很多其他的指令操作，不过我这边就不一一列举，可以到Redis中文网去看String的指令操作(<a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3508.html)%E3%80%82">https://www.redis.net.cn/tutorial/3508.html)。</a></p>
<p>String的value是二进制安全的，你可以存二进制。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。肯定有人会问Redis中可以存多少个Key，目前Redis可以存2^32个Key。</p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）.一个列表最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p>List常用的指令有<code>LPUSH</code>、<code>LPOP</code>、<code>LLEN</code>、<code>LPUSHX</code>、<code>LRANGE</code>、<code>LSET</code>、<code>LINDEX</code>、<code>BLPOP</code>这些常用的指令。我这边展示很多都是Left也就是从List左侧进行操作，在Redis中List更像一个队列，而且是一个双向的队列，它还有Right相关的操作，例如<code>RPOP</code>、<code>RPUSH</code>等等都是操作列表尾部的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey redis &#x2F;&#x2F;将redis从头部插入数据向w3ckey列表。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mongodb &#x2F;&#x2F;将mongodb从头部插入数据向w3ckey列表。</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mysql &#x2F;&#x2F;将mysql从头部插入数据向w3ckey列表</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 10 &#x2F;&#x2F;这个地方也可以0 -1 显示全部，展示0-10的数据 </span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; RPOP w3ckey &#x2F;&#x2F;从尾部弹出一个元素</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 -1 &#x2F;&#x2F;展示全部数据</span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH w3ckey hbase &#x2F;&#x2F;从尾部插入hbase数据</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 -1 </span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;hbase&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LPOP w3ckey &#x2F;&#x2F;从头部弹出数据</span><br><span class="line">&quot;mysql&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 -1</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;hbase&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LLEN w3ckey &#x2F;&#x2F;显示列表长度</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LSET w3ckey 1 kafka &#x2F;&#x2F;像位置为1的地方插入数据kafka</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 -1 &#x2F;&#x2F;从结果我们可以看出来hbase被覆盖。0是mongodb</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;kafka&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LINDEX w3ckey 1 &#x2F;&#x2F;获取索引下标是1的数据</span><br><span class="line">&quot;kafka&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 -1 &#x2F;&#x2F;从结果我们可以看出来这个数据还在集合里面，没有被弹出</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;kafka&quot;</span><br></pre></td></tr></table></figure>

<p>List可以用于分布式队列，或者是栈。这样就可以多个应用共同消费不会有重复消费的情况。如果是做一个队列使用的是<code>LPUSH</code>+<code>RPOP</code>这两个指令从头（左端）插入，从尾部（右端）弹出。如果做一个栈的化，使用<code>LPUSH</code>+<code>LPOP</code>这种一般会使用即先进后出，从头部（左侧）插入，头部弹出。</p>
<p>这种可以使用做微博的TimeLine或者是报警，存储的消息队列（根据生产者和消费者模型）。</p>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。Redis 中每个 hash 可以存储 2^32 - 1 键值对（4294967295）</p>
<p>Hash我像大家应该都不陌生，Hash在计算机里面是经常见到的一个词汇，所以Hash这个比较容易理解的。Redis里的Hash和我们平时看到的HashMap差不多。</p>
<p>常用的指令有<code>HSET Key Field Value</code>、<code>HMSET Key [Filed1 Value1] Field2 Value2</code>、<code>HGET Key Field</code>、<code>HGETALL Key</code> 、<code>HLEN Key</code>、<code>HMGET Key [Field1] Field2</code>、<code>HDEL Key [Field1] Field2</code>、<code>HVALS Key</code> 、<code>HSETNX Key Field Value</code>、<code>HEXISTS Key Field</code>等常用指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET w3ckey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000   </span><br><span class="line">OK   &#x2F;&#x2F;设置Hash 键 name 值 redis tutorial 键 likes 值 20 等等</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL w3ckey 获取所有key和value</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HGET w3ckey name &#x2F;&#x2F;获取Hash种单个key里面的值</span><br><span class="line">&quot;redis tutorial&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HSET w3ckey address home &#x2F;&#x2F;设置Hash中 address的值是home</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; HLEN w3ckey &#x2F;&#x2F;获取Hash的大小</span><br><span class="line">5</span><br><span class="line">redis 127.0.0.1:6379&gt; HVALS w3ckey &#x2F;&#x2F;获取Hash中所有的value值</span><br><span class="line">1) &quot;redis tutorial&quot;</span><br><span class="line">2) &quot;redis basic commands for caching&quot;</span><br><span class="line">3) &quot;20&quot;</span><br><span class="line">4) &quot;23000&quot;</span><br><span class="line">5) &quot;home&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HMGET w3ckey name address &#x2F;&#x2F;获取Hash中 key是name key是address的值</span><br><span class="line">1) &quot;redis tutorial&quot;</span><br><span class="line">2) &quot;home&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HDEL w3ckey description &#x2F;&#x2F;删除Hash中的description</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL w3ckey &#x2F;&#x2F;description被删除了</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;likes&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;visitors&quot;</span><br><span class="line">6) &quot;23000&quot;</span><br><span class="line">7) &quot;address&quot;</span><br><span class="line">8) &quot;home&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HEXISTS w3ckey name &#x2F;&#x2F;Hash中存在name这个key，存在返回1不存在返回0</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; HSETNX w3ckey name redis-cluster &#x2F;&#x2F;与SETNX类似，设置Key中不存在的值</span><br><span class="line">(integer) 0 &#x2F;&#x2F;失败返回0，已经存在name这个key</span><br><span class="line">redis 127.0.0.1:6379&gt; HSETNX w3ckey age 100 &#x2F;&#x2F;设置成功age这个key</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL w3ckey</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;likes&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;visitors&quot;</span><br><span class="line">6) &quot;23000&quot;</span><br><span class="line">7) &quot;address&quot;</span><br><span class="line">8) &quot;home&quot;</span><br><span class="line">9) &quot;age&quot;</span><br><span class="line">10) &quot;100&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HSCAN w3ckey 0 match a* count 100 &#x2F;&#x2F;HSCAN 当key比较多可以使用迭代器</span><br><span class="line">1) &quot;0&quot;                                                &#x2F;&#x2F;方式去查找相关的key这个是匹配所有a</span><br><span class="line">2) 1) &quot;address&quot;										  &#x2F;&#x2F;打头的key。用于模糊查找key。</span><br><span class="line">2) &quot;home&quot;			</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>根据Key获取值，主要用于缓存对象类的数据。一把都会把数据序列化，提高存储效率。举个例子可以存储购物车信息。以用户id为key，商品id为field，商品数量为value。</p>
<p>Hash的优点：同类数据归类整合储存，方便数据管理；相比String操作消耗内存与cpu更小；相比String储存更节省空间。</p>
<p>Hash的缺点：过期功能不能使用在field上，只能用在key上，Redis集群架构下不适合大规模使用。]</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p>常用的指令有<code>SADD</code>、 <code>SMEMBERS</code>、<code>SPOP</code>、<code>SCARD</code>这种和List类似的操做，还提供集合操作比如<code>SDIFF</code>、<code>SINTER</code>、<code>SUNION</code>这种差集，交集和并集的操作。这样可以在做大数据量的集合运算使用Redis。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS w3ckey</span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; SCARD w3ckey</span><br><span class="line">3</span><br><span class="line">redis 127.0.0.1:6379&gt;SPOP w3ckey</span><br><span class="line">&quot;mysql&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS wc</span><br><span class="line">1) &quot;333&quot;</span><br><span class="line">2) &quot;211&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;212&quot;</span><br><span class="line">5) &quot;222&quot;</span><br><span class="line">6) &quot;111&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; SSCAN wc 0 match 2* count 10 &#x2F;&#x2F;迭代器，用于模糊查找和匹配</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;222&quot;</span><br><span class="line">2) &quot;211 </span><br><span class="line">3) &quot;212&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Set是和List差不多的数据结构，它比较像Java中的HashSet，和Java底层HashSet使用的是HashMap一样，这个Set使用的也是Hash。它和List比的好处就是它可以去重。比如你简单的统计用户访问量这种久可以用到Set这种数据结构。每一个用户来的时候我久在这个Set上加一。但是当数据量特别大的时候也不适合用Set去做，这种只是个临时方案。我们可以使用Redis不常用的数据结构比如一个BitMap或者HyperLogLog这种。</p>
<p>因为Set有很强的集合运算能力在很多社交应用会用到。比如使用使用sinter就可以计算出两个用户兴趣的交集。将两个用户和标签分别存储成两个Set（key是用户信息，set是标签数据）然后两个set做交集算出兴趣集合，当集合数量大于某个数就可以推荐好友了。不过用HaSet也可以做。</p>
<p>spop可以从集合中随机弹出元素，srandmember可以随机取出一个元素，但是不删除这个元素，这两个命令都可以实现不用需求的抽奖系统；还有微信，微博点赞功能。</p>
<p>微信抽奖小程序：1）点击参与抽奖加入集合 SADD key {userID}；2）查看参与抽奖所有用户 SMEMBERS key；3）抽奖count名中奖者 SRANDMEMBER key [count] / SPOP key [count]</p>
<p>微信微博点赞、收藏、标签：1）点赞；ADD like:{消息ID} {用户ID}；2）取消点赞 SREM like:{消息ID} {用户ID}；3）检查用户是否点过赞 SISMEMBER like:{消息ID} {用户ID}；4）获取点赞的用户列表 SMEMBERS like:{消息ID}；5）获取点赞用户数；SCARD like:{消息ID}</p>
<h5 id="Zset（sorted-set）"><a href="#Zset（sorted-set）" class="headerlink" title="Zset（sorted set）"></a>Zset（sorted set）</h5><p>Redis的有序的集合。Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>在Zset中有三个区间要掌握，索引区间，字典区间，分数区间。分数区间时比较好算的，我们在设置值的时候都会指定分数，在一个就是索引区间，这个你返回值时候的下标，那个时索引。还有就是字典区间，这个时根据你设置的值中字典值。我们知道Zset中存储时String所以久可以根据字符串计算区间。（1，123，2）这种类型的区间。</p>
<p>一般指令时根据索引区间，LEX相关是字典区间，带SCORE的是分数区间。   </p>
<p>Zset里面有很多实用的指令<code>ZADD key [score value] score1 value1</code>、<code>ZRANGE key start end [WITHSCORES] </code>、<code>ZCARD key</code>、<code>ZINCRBY key increment member</code>、<code>ZRANGEBYLEX key min max</code>、<code>ZRANGEBYSCORE key min max</code>、<code>ZSCORE key member</code>、<code>ZREM key member [member ...]</code>、<code>ZREMRANGEBYSCORE key min max</code>、<code>ZREMRANGEBYRANK key start stop</code>、<code>ZREVRANGE key start stop</code>、<code>ZREVRANGEBYSCORE key max min</code>、<code>ZREVRANK key</code>、<code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></p>
<p>后面还有<code>ZPOPMAX</code> 、<code>ZPOPMIN</code>、<code>BZPOPMAX</code>、<code>BZPOPMIN</code>弹出最大值，最小值和阻塞弹出最大值最小值。不过这个是在Redis5.0.0后面版本才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt;ZADD w3ckeyz 1 redis &#x2F;&#x2F;向集合中增加值和分数</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD w3ckeyz 2 mongo</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD w3ckeyz 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD w3ckeyz 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD w3ckeyz 2 hbase</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD w3ckeyz 6 row</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE w3ckeyz 0 -1 &#x2F;&#x2F;展示集合中所有的值</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hbase&quot;</span><br><span class="line">3) &quot;mongo&quot;</span><br><span class="line">4) &quot;mysql&quot;</span><br><span class="line">5) &quot;row&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE w3ckeyz 0 10 WITHSCORES &#x2F;&#x2F;根据Scores来展示集合中所有的值，有序</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) 1.0</span><br><span class="line">3) &quot;hbase&quot;</span><br><span class="line">4) 2.0</span><br><span class="line">5) &quot;mongo&quot;</span><br><span class="line">6) 2.0</span><br><span class="line">7) &quot;mysql&quot;</span><br><span class="line">8) 4.0</span><br><span class="line">9) &quot;row&quot;</span><br><span class="line">10) 6.0</span><br><span class="line">127.0.0.1:6379&gt; ZCARD w3ckeyz &#x2F;&#x2F;获取集合中元素多少</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt;ZCOUNT w3ckeyz 0 2 &#x2F;&#x2F;根据集合分数区间获取元素个数</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY w3ckeyz 4 mysql &#x2F;&#x2F;mysql元素增加3</span><br><span class="line">8.0</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE w3ckeyz 0 10 WITHSCORES &#x2F;&#x2F;mysql 分数已经变了</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) 1.0</span><br><span class="line">3) &quot;hbase&quot;</span><br><span class="line">4) 2.0</span><br><span class="line">5) &quot;mongo&quot;</span><br><span class="line">6) 2.0</span><br><span class="line">7) &quot;row&quot;</span><br><span class="line">8) 6.0</span><br><span class="line">9) &quot;mysql&quot;</span><br><span class="line">10) 8.0</span><br><span class="line">127.0.0.1:6379&gt;ZLEXCOUNT w3ckeyz - + &#x2F;&#x2F;- +是获取集合的长度。根据字符串长度，这个指令一般在分数相同</span><br><span class="line">(integer) 5&#x2F;&#x2F;时元素使用会比较好用。它里面都是按照Sting去存的1，128，2类似这样顺序。如果分数不同则不是很推荐使用。我没太看懂分数不同的返回值，这个可以使用ZRANGEBYLEX，这个指令来看。</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g</span><br><span class="line">(integer) 7</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYLEX myzset - [c &#x2F;&#x2F;获取C之前的元素，包含c</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYLEX myzset - (c &#x2F;&#x2F;获取C之前的元素，不包含c</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYLEX myzset [aaa (g &#x2F;&#x2F;获取a到g之间的元素不包括g </span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;f&quot; </span><br><span class="line">redis 127.0.0.1:6379&gt; ZLEXCOUNT myzset [b [f &#x2F;&#x2F;获取b到f的元素，这里分数都一样比较好用</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE w3ckeyz 0 2 &#x2F;&#x2F;根据分数区间获取值</span><br><span class="line">1) &quot;mac&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;hbase&quot;</span><br><span class="line">4) &quot;mongo&quot;</span><br><span class="line">5) &quot;windows&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE w3ckeyz 0 2 WITHSCORES &#x2F;&#x2F;根据分数区间获取值和分数</span><br><span class="line">1) &quot;mac&quot;</span><br><span class="line">2) 1.0</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) 1.0</span><br><span class="line">5) &quot;hbase&quot;</span><br><span class="line">6) 2.0</span><br><span class="line">7) &quot;mongo&quot;</span><br><span class="line">8) 2.0</span><br><span class="line">9) &quot;windows&quot;</span><br><span class="line">10) 2.0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZSCORE w3ckeyz mac &#x2F;&#x2F;获取集合中值的SCORE</span><br><span class="line">1.0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZREM w3ckeyz windows &#x2F;&#x2F;删除windows这个元素</span><br><span class="line">1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZREMRANGEBYSCORE w3ckeyz 6 8 &#x2F;&#x2F;删除SCORE6-8这个区间的元素</span><br><span class="line">2</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE w3ckeyz 0 -1 WITHSCORES &#x2F;&#x2F;展示所有元素</span><br><span class="line">1) &quot;mac&quot;</span><br><span class="line">2) 1.0</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) 1.0</span><br><span class="line">5) &quot;hbase&quot;</span><br><span class="line">6) 2.0</span><br><span class="line">7) &quot;mongo&quot;</span><br><span class="line">8) 2.0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZREMRANGEBYRANK w3ckeyz 0 1 &#x2F;&#x2F;删除索引0，1区间数据</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE w3ckeyz 0 -1 WITHSCORES </span><br><span class="line">1) &quot;hbase&quot;</span><br><span class="line">2) 2.0</span><br><span class="line">3) &quot;mongo&quot;</span><br><span class="line">4) 2.0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZREVRANGE w3ckeyz 0 -1 WITHSCORES</span><br><span class="line">1) &quot;dog&quot; 									&#x2F;&#x2F;有序集中指定区间内的成员，通过索引，分数从高到底</span><br><span class="line">2) 7.0</span><br><span class="line">3) &quot;cat&quot;</span><br><span class="line">4) 6.0</span><br><span class="line">5) &quot;hat&quot;</span><br><span class="line">6) 5.0</span><br><span class="line">7) &quot;linux&quot;</span><br><span class="line">8) 3.0</span><br><span class="line">9) &quot;mongo&quot;</span><br><span class="line">10) 2.0</span><br><span class="line">11) &quot;hbase&quot;</span><br><span class="line">12) 2.0</span><br><span class="line">13) &quot;mysql&quot;</span><br><span class="line">14) 1.0</span><br><span class="line">15) &quot;redis&quot;</span><br><span class="line">16) 0.0</span><br><span class="line">17) &quot;client&quot;</span><br><span class="line">18) 0.0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZREVRANGEBYSCORE w3ckeyz 7 0</span><br><span class="line">1) &quot;dog&quot;								&#x2F;&#x2F;有序集中指定区间内的成员，通过SCORE，分数从高到底	</span><br><span class="line">2) &quot;cat&quot;</span><br><span class="line">3) &quot;hat&quot;</span><br><span class="line">4) &quot;linux&quot;</span><br><span class="line">5) &quot;mongo&quot;</span><br><span class="line">6) &quot;hbase&quot;</span><br><span class="line">7) &quot;mysql&quot;</span><br><span class="line">8) &quot;redis&quot;</span><br><span class="line">9) &quot;client&quot;</span><br></pre></td></tr></table></figure>

<p>Zset可以使用做排行榜，这个是很容易的，因为每个元素都有score分数。Zset同样也可以用于社交和抽奖。而且有权重可以做设计推送权重比如多层次的好友，比如一级，二级，三级好友，这种就是通过Score去排序。使用Zset去做时间线（TimeLine） ，key是做的事情，Score是时间。用户投票，实时排行信息包含直播间在线用户列表，弹幕消息（可以理解为按消息维度的消息排行榜）。</p>
<h4 id="Redis不常用的3种数据结构"><a href="#Redis不常用的3种数据结构" class="headerlink" title="Redis不常用的3种数据结构"></a>Redis不常用的3种数据结构</h4><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。该结构使用一种近似值算法，标准误差0.81%。</p>
<p>HyperLogLog 在Redis实现也是有意思的，有时间可以写一个关于这种数据结构的解析，它其实和布隆过滤器有点像，都是通过位存储来实现大量数据的存储。（布隆过滤器是经过多次hash形成位存储），不过这两种方法导致计算方法会有一定偏差。千万级数据集下，随机数误差基本低于 1.5%， 完全不重复情况下误差也不超过 2%</p>
<p>常用的几种指令<code>PFADD</code> 、<code>PFCOUNT</code>、<code>PFMERGE</code>这几种指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey redis &#x2F;&#x2F;向key中增加值 </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey mysql4</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey hbase</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey mongo</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT w3ckey</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey mongo &#x2F;&#x2F;向HyperLogLog中增加相同的值，返回结果为0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT w3ckey &#x2F;&#x2F;结果没增加值，说明HyperLogLog是一个无重复的集合。</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey1 db</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD w3ckey1 cache</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT w3ckey1</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; PFMERGE w3ckey w3ckey1 &#x2F;&#x2F;合并两个key中数据，两个key是有相同数据。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT w3ckey &#x2F;&#x2F;从结果我们能看出去重了，不是5+3 而是5+2</span><br><span class="line">(integer) 7</span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT w3ckey1 &#x2F;&#x2F;从结果看是合并到w3ckey上，原来的key没有变</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面提到一个词是基数基数，简单介绍基数计数。</p>
<p>**基数计数(cardinality counting)**：通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。 要实现基数计数，最简单的做法是记录集合中所有不重复的元素集合S，当新来一个元素x，若S中不包含元素x，则将x加入S，否则不加入，计数值就是S的元素数量。这种做法存在两个问题：</p>
<ol>
<li>当统计的数据量变大时，相应的存储内存也会线性增长</li>
<li>当集合S变大，判断其是否包含新加入元素i的成本变大</li>
</ol>
<p>HyperLogLog用于解决这种基数统计问题就很ok，它的误差率我们上面也提到在很大数据量时候，误差也是可以接受对于统计UV这种数据。还有就是IP访问量，计算搜索词的热度（每个搜索词的搜索个数，不同的用户）</p>
<h5 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h5><p>BitMap是位图，它是一串连续的二进制数字（0或1），每一位所在的位置为偏移(offset)，在BitM ap上可执行AND,OR,XOR以及其它位操作。不过Redis这里只存储位置信息和，位置的bit信息。也就是redis只知道哪个位置是0那个位置是1，这样比较白话。它存储位数2^32-1个。</p>
<p>基于最小的单位bit进行存储，所以非常省空间。设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的。二进制数据的存储，进行相关计算的时候非常快。方便扩容</p>
<p>Redis中BitMap被限制在512MB之内，所以最大是2^32位。建议每个key的位数都控制下，因为读取时候时间复杂度O(n)，越大的串读的时间花销越多。因为BitMap是存在Redis的String中</p>
<p>常用的指令就是指定和获取key某个位置的bit值。<code>SETBIT key  offset 1 or 0</code>、<code>GETBIT key offset</code> 、<code>BITCOUNT key</code>、<code>BITOP</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SETBIT hello 100 1 &#x2F;&#x2F;设置hello这个key 第100位为1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT hello 200 1 &#x2F;&#x2F;设置hello这个key 第200位为1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT hello 100  &#x2F;&#x2F;获取hello这个key 第100位置信息，结果返回是1</span><br><span class="line">1</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT hello 200  &#x2F;&#x2F;获取hello这个key 第200位置信息，结果返回是1</span><br><span class="line">1</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT hello 10 &#x2F;&#x2F;获取hello这个key 第10位设置信息，结果返回是0，没有初始化</span><br><span class="line">redis 127.0.0.1:6379&gt; BITCOUNT hello &#x2F;&#x2F;计算hello这个key 有多少个位置被设置值</span><br><span class="line">2</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT bits-1 0 1        &#x2F;&#x2F;bits-1 &#x3D; 1001</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT bits-1 3 1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT bits-2 0 1        &#x2F;&#x2F; bits-2 &#x3D; 1011</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT bits-2 1 1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; SETBIT bits-2 3 1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; BITOP AND and-result bits-1 bits-2</span><br><span class="line">1</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT and-result 0     &#x2F;&#x2F; and-result &#x3D; 1001</span><br><span class="line">1</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT and-result 1</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT and-result 2</span><br><span class="line">0</span><br><span class="line">redis 127.0.0.1:6379&gt; GETBIT and-result 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>一般BitMap用作大数据处理，比如之前说的日活统计，重复点赞等。不过BitMap存储的是准确的数据。（不像HyperLogLog是由概率问题）。</p>
<p>可以根据用户Id然后hash一个位置，在这个位置上设置位1，表明一个用户来过。可以统计UV。同样也可以去做他的相关额基数统计，不过这种会随着量增大，会增大，但也不会很大和HyperLogLog比消耗还是比较大的，但是与Set像比还是可以的，比较省内存的，毕竟内存也是钱啊，而且它的数据是准的不会有误差。</p>
<h5 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h5><p>Geo相关的操作指令和存储，是Redis专门为地理位置信息服务的，它主要把地理位置信息按照经纬度存储起来，然后去计算地理位置相关的操作，比如计算两个点的距离，根据具体坐标获取范围内的经纬度坐标等；它主要用于LBS相关的系统。使用Geo相关的指令和操作要在Redis版本3.2以上。</p>
<p><code>常用的Geo指令 geoadd</code>、<code>geopos</code>、<code>geodist</code>、<code>georadius</code>、<code>georadiusbymember</code>、<code>geohash</code>等。根据这些指令我们就可以堆地理信息进行操作。然后根绝业务获取我们想要的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; </span><br><span class="line">(integer) 2 &#x2F;&#x2F;设置Sicily key 两个地址Palermo和Catania</span><br><span class="line">redis 127.0.0.1:6379&gt; GEODIST Sicily Palermo Catania &#x2F;&#x2F;计算Sicily key的两个节点的距离</span><br><span class="line">&quot;166274.15156960039&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; GEORADIUS Sicily 15 37 100 km &#x2F;&#x2F;获取经度15纬度37 100Km距离内的位置信息</span><br><span class="line">1) &quot;Catania&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; GEORADIUS Sicily 15 37 200 km &#x2F;&#x2F;获取经度15纬度37 200Km距离内的位置信息</span><br><span class="line">1) &quot;Palermo&quot;</span><br><span class="line">2) &quot;Catania&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; GEORADIUS Sicily 15 37 200 km WITHDIST &#x2F;&#x2F;带出距离信息</span><br><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) &quot;190.4424&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) &quot;56.4413&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD &#x2F;&#x2F;带出距离信息和经纬度信息</span><br><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) 1) &quot;13.361389338970184&quot;</span><br><span class="line">      2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) 1) &quot;15.087267458438873&quot;</span><br><span class="line">      2) &quot;37.50266842333162&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; GEOPOS Sicily Palermo Catania NonExisting &#x2F;&#x2F;获取节点的经纬度信息</span><br><span class="line">1) 1) &quot;13.361389338970184&quot;</span><br><span class="line">   2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;15.087267458438873&quot;</span><br><span class="line">   2) &quot;37.50266842333162&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">redis 127.0.0.1:6379&gt; GEOADD Sicily 13.583333 37.316667 &quot;Agrigento&quot; &#x2F;&#x2F;添加节点信息</span><br><span class="line">redis 127.0.0.1:6379&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km &#x2F;&#x2F;返回这个位置信息100km内的位置信息</span><br><span class="line">1) &quot;Agrigento&quot;</span><br><span class="line">2) &quot;Palermo&quot;</span><br></pre></td></tr></table></figure>

<p>用到的单位：m 表示单位为米。km 表示单位为千米。mi 表示单位为英里。ft 表示单位为英尺</p>
<p>我们除了使用附近的人，还有关于打车定位距离这些信息可以使用，还有很多应用场景。在内存中计算很快，特别是对那些实时性要求高的业务系统来说这些都是用的。</p>
<h4 id="Redis是如何保证高性能"><a href="#Redis是如何保证高性能" class="headerlink" title="Redis是如何保证高性能"></a>Redis是如何保证高性能</h4><p>1、Redis是单线程，没有上下文切换，所以执行效率比较快。</p>
<p>2、Redis是纯内存数据库，除了持久化都在内存上操作，CPU之恶映射地址，直接读取数据，所以很快。</p>
<p>3、使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>
<p>4、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。比如跳表，压缩表，还有SDS。</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p>PS:Redis真的是单线程吗，有没有多线程的时候。Redis在进行进行过期Key删除的时候使用的是多线程。不过这不影响它插入和读取，我们最常用就是插入和读取。</p>
<h4 id="Redis使用的一些小建议"><a href="#Redis使用的一些小建议" class="headerlink" title="Redis使用的一些小建议"></a>Redis使用的一些小建议</h4><p>1、所有Redis的key都要设置过期时间，这样就不会导致一些过期和垃圾的Key产生，大多数Redis都是做缓存，所以要保证时效性。</p>
<p>2、Redis的使用一定要分应用，应用隔离会使得Redis内存不会因为其他机器异常导致，本身服务不可用，因为内存毕竟不是一个可以压缩的资源。相对CPU来讲。</p>
<p>3、Redis的后面可以使用lettuce代替jedis，lettuce这个是使用netty做底层，而不是jedis使用的线程池去做。所以不会由线程释放问题。性能也会好很多</p>
<p>4、redis中两种持久化方式都要打开，RDB和AOF这样可以保证当Redis挂掉后可以根据RDB迅速把数据热起来，然后根据AOF在恢复近期的数据，进行修复。</p>
<p>5、Redis的集群由两种一种是Codis集中式和redis-cluster点对点模式两种，目前比较推荐使用redis-cluster做分片，首先这个是官方维护，后面可以一致使用。Codis的github已经不够活跃，同时codis好多指令也是不支持在分布式情况下。肯定有人会问哨兵模式会用的把，这两种无论那种在做HA（高可用）时候都会使用哨兵模式。即每个分片节点都是一个集群。</p>
<p>6、Redis的集群管理可以使用搜狐的缓存云cacheCloud进行管理，不过这个也不怎么活跃了。</p>
<p>7、当处理一些复杂业务和批量操作的时候使用lua或者pipleline。Redis后面瓶颈不是CPU而是网络，复杂业务频繁网络请求会降低Redis的使用性能。</p>
<p>8、Redis在进行大的Key存储一定要进行压缩或者序列化，不顾序列化选型也很关键，不要选效率比较低的。不然在高并发的时候你的所有CPU资源都用来序列化和反序列化这样导致你应用CPU过高的同时，频繁GC。</p>
<p>9、不要使用Key*这种扫描全部Key的指令，禁用效率低的指令。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://redis.io/">Redis</a></p>
<p><a target="_blank" rel="noopener" href="https://www.redis.net.cn/">Redis中文网</a></p>
<p><a target="_blank" rel="noopener" href="http://try.redis.io/">Try Redis</a>   这个上敲Redis命令真的爽，不用自己创建Redis</p>
<p><a target="_blank" rel="noopener" href="http://redisdoc.com/">RedisDOC</a></p>
<p><a target="_blank" rel="noopener" href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html">神奇的HyperLogLog算法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.huangz.me/diary/2015/redis-geo.html">huangz/blog</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Hill</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.51cloud.win/2020/03/16/%E6%B5%85%E8%B0%88Redis/">https://blog.51cloud.win/2020/03/16/%E6%B5%85%E8%B0%88Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/img/00018.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/16/%E6%B5%85%E8%B0%88Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84SDS/"><img class="prev-cover" src="/img/00020.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">浅谈Redis底层-SDS</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/16/%E6%B5%85%E8%B0%88volatile/"><img class="next-cover" src="/img/00002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">浅谈volatile</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/04/16/浅谈Redis底层数据结构SDS/" title="浅谈Redis底层-SDS"><img class="cover" src="/img/00020.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-16</div><div class="title">浅谈Redis底层-SDS</div></div></a></div><div><a href="/2020/05/16/浅谈Redis底层-SkipList/" title="浅谈Redis底层-SkipList"><img class="cover" src="/img/00021.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-16</div><div class="title">浅谈Redis底层-SkipList</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/dog.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Hill</div><div class="author-info__description">Stay Hungary Stay Foolish</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ClaudeWilliam"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ClaudeWilliam" target="_blank" title="github"><i class="GitHub"></i></a><a class="social-icon" href="https://twitter.com/qjqandjack" target="_blank" title="twitter"><i class="Twitter"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%B8%B8%E7%94%A8%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Redis常用的5种数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String"><span class="toc-number">2.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#List"><span class="toc-number">2.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hash"><span class="toc-number">2.3.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set"><span class="toc-number">2.4.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Zset%EF%BC%88sorted-set%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">Zset（sorted set）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%843%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Redis不常用的3种数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">3.1.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BitMap"><span class="toc-number">3.2.</span> <span class="toc-text">BitMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Geo"><span class="toc-number">3.3.</span> <span class="toc-text">Geo</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">Redis是如何保证高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%BB%BA%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">Redis使用的一些小建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/25/Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVC-%E4%B8%8B%E7%AF%87/" title="Spring如何实现MVC-下篇（SpringBoot是如何实现初始化）"><img src="/img/00031.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring如何实现MVC-下篇（SpringBoot是如何实现初始化）"/></a><div class="content"><a class="title" href="/2021/06/25/Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVC-%E4%B8%8B%E7%AF%87/" title="Spring如何实现MVC-下篇（SpringBoot是如何实现初始化）">Spring如何实现MVC-下篇（SpringBoot是如何实现初始化）</a><time datetime="2021-06-25T12:03:14.000Z" title="Created 2021-06-25 20:03:14">2021-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/25/Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVC-%E4%B8%8A%E7%AF%87/" title="Spring如何实现MVC-上篇"><img src="/img/00029.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring如何实现MVC-上篇"/></a><div class="content"><a class="title" href="/2021/05/25/Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVC-%E4%B8%8A%E7%AF%87/" title="Spring如何实现MVC-上篇">Spring如何实现MVC-上篇</a><time datetime="2021-05-25T12:03:14.000Z" title="Created 2021-05-25 20:03:14">2021-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/16/MySQL%E4%B8%AD%E7%9A%84binlog%E3%80%81redolog/" title="MySQL中的binlog、redolog"><img src="/img/00001.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL中的binlog、redolog"/></a><div class="content"><a class="title" href="/2020/10/16/MySQL%E4%B8%AD%E7%9A%84binlog%E3%80%81redolog/" title="MySQL中的binlog、redolog">MySQL中的binlog、redolog</a><time datetime="2020-10-16T02:21:08.000Z" title="Created 2020-10-16 10:21:08">2020-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/16/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BARocketMQ/" title="浅入浅出RocketMQ"><img src="/img/00017.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅入浅出RocketMQ"/></a><div class="content"><a class="title" href="/2020/09/16/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BARocketMQ/" title="浅入浅出RocketMQ">浅入浅出RocketMQ</a><time datetime="2020-09-16T01:21:08.000Z" title="Created 2020-09-16 09:21:08">2020-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/16/%E6%B5%85%E8%B0%88%E6%B3%9B%E5%9E%8B/" title="泛型"><img src="/img/00022.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="泛型"/></a><div class="content"><a class="title" href="/2020/08/16/%E6%B5%85%E8%B0%88%E6%B3%9B%E5%9E%8B/" title="泛型">泛型</a><time datetime="2020-08-16T01:21:08.000Z" title="Created 2020-08-16 09:21:08">2020-08-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By Hill</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>